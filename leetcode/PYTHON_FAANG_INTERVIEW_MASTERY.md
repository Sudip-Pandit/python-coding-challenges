# ðŸš€ PYTHON INTERVIEW MASTERY - TOP TECH COMPANIES GUIDE

**Complete Collection of Essential Problems & Solutions for FAANG & Big Tech Companies**

---

## TABLE OF CONTENTS

1. [Company-Specific Problem Lists](#company-specific)
2. [Core Coding Patterns](#core-patterns)
3. [Essential Data Structure Problems](#essential-ds)
4. [Algorithm Mastery Problems](#algorithms)
5. [System Design Patterns](#system-design)
6. [LeetCode Hard Problems](#leetcode-hard)
7. [Real Interview Questions](#real-questions)
8. [Practice Schedule](#practice-schedule)

---

# COMPANY-SPECIFIC PROBLEM LISTS {#company-specific}

## Google Top 25 Problems

### String & Array Problems
1. **Two Sum** - LeetCode #1
2. **Longest Substring Without Repeating Characters** - LeetCode #3
3. **Median of Two Sorted Arrays** - LeetCode #4
4. **Longest Palindromic Substring** - LeetCode #5
5. **ZigZag Conversion** - LeetCode #6
6. **Reverse Integer** - LeetCode #7
7. **String to Integer (atoi)** - LeetCode #8
8. **Palindrome Number** - LeetCode #9
9. **Container With Most Water** - LeetCode #11
10. **3Sum** - LeetCode #15

### Linked List Problems
11. **Add Two Numbers** - LeetCode #2
12. **Merge k Sorted Lists** - LeetCode #23
13. **Reverse Nodes in k-Group** - LeetCode #25

### Tree Problems
14. **Binary Tree Level Order Traversal** - LeetCode #102
15. **Lowest Common Ancestor of a Binary Tree** - LeetCode #236
16. **Serialize and Deserialize Binary Tree** - LeetCode #297

### Dynamic Programming
17. **Regular Expression Matching** - LeetCode #10
18. **Best Time to Buy and Sell Stock IV** - LeetCode #188

### Graph Problems
19. **Course Schedule II** - LeetCode #210
20. **Alien Dictionary** - LeetCode #269

### Advanced
21. **Trapping Rain Water** - LeetCode #42
22. **Sliding Window Maximum** - LeetCode #239
23. **Word Ladder II** - LeetCode #126
24. **Minimum Window Substring** - LeetCode #76
25. **Design Search Autocomplete System** - LeetCode #642

---

## Amazon Top 25 Problems

### Array & String
1. **Two Sum** - LeetCode #1
2. **Best Time to Buy and Sell Stock** - LeetCode #121
3. **Merge Sorted Array** - LeetCode #88
4. **Meeting Rooms II** - LeetCode #253
5. **Merge Intervals** - LeetCode #56
6. **Insert Interval** - LeetCode #57
7. **Rotate Array** - LeetCode #189
8. **Move Zeroes** - LeetCode #283

### Linked List
9. **Reverse Linked List** - LeetCode #206
10. **Palindrome Linked List** - LeetCode #234

### Tree
11. **Binary Tree Level Order Traversal** - LeetCode #102
12. **Validate Binary Search Tree** - LeetCode #98
13. **Maximum Path Sum** - LeetCode #124
14. **Rightmost Column with at least a One** - LeetCode #Binary Matrix

### Design
15. **LRU Cache** - LeetCode #146
16. **Min Stack** - LeetCode #155
17. **Flatten Nested List Iterator** - LeetCode #341

### Graph & BFS
18. **Number of Islands** - LeetCode #200
19. **Word Ladder** - LeetCode #127
20. **Pacific Atlantic Water Flow** - LeetCode #417

### Dynamic Programming
21. **Longest Increasing Subsequence** - LeetCode #300
22. **House Robber** - LeetCode #198
23. **Decode Ways** - LeetCode #91

### Advanced
24. **Trapping Rain Water** - LeetCode #42
25. **Largest Rectangle in Histogram** - LeetCode #84

---

## Facebook (Meta) Top 25 Problems

### Core Problems
1. **Two Sum** - LeetCode #1
2. **Add Two Numbers** - LeetCode #2
3. **Longest Substring Without Repeating Characters** - LeetCode #3
4. **Container With Most Water** - LeetCode #11
5. **3Sum** - LeetCode #15
6. **Valid Parentheses** - LeetCode #20

### String Problems
7. **Longest Palindromic Substring** - LeetCode #5
8. **Multiply Strings** - LeetCode #43
9. **Next Permutation** - LeetCode #31

### Array Problems
10. **Remove Duplicates from Sorted Array** - LeetCode #26
11. **Best Time to Buy and Sell Stock** - LeetCode #121
12. **Rotate Image** - LeetCode #48

### Linked List
13. **Reverse Linked List** - LeetCode #206
14. **Swap Nodes in Pairs** - LeetCode #24
15. **Merge k Sorted Lists** - LeetCode #23

### Tree & Binary Search
16. **Binary Tree Level Order Traversal** - LeetCode #102
17. **Lowest Common Ancestor of a Binary Tree** - LeetCode #236
18. **Validate Binary Search Tree** - LeetCode #98

### Graph & Matrix
19. **Number of Islands** - LeetCode #200
20. **Rotting Oranges** - LeetCode #994

### Recursion & Backtracking
21. **Word Break II** - LeetCode #140
22. **Permutations** - LeetCode #46
23. **Combinations** - LeetCode #77

### Design
24. **LRU Cache** - LeetCode #146
25. **Design Search Autocomplete System** - LeetCode #642

---

## Microsoft Top 20 Problems

1. **Two Sum** - LeetCode #1
2. **Add Two Numbers** - LeetCode #2
3. **Longest Substring Without Repeating Characters** - LeetCode #3
4. **Median of Two Sorted Arrays** - LeetCode #4
5. **Merge k Sorted Lists** - LeetCode #23
6. **Valid Parentheses** - LeetCode #20
7. **Container With Most Water** - LeetCode #11
8. **Best Time to Buy and Sell Stock** - LeetCode #121
9. **Word Ladder** - LeetCode #127
10. **Number of Islands** - LeetCode #200
11. **LRU Cache** - LeetCode #146
12. **Binary Tree Level Order Traversal** - LeetCode #102
13. **Course Schedule II** - LeetCode #210
14. **Trapping Rain Water** - LeetCode #42
15. **Sliding Window Maximum** - LeetCode #239
16. **Minimum Window Substring** - LeetCode #76
17. **Regular Expression Matching** - LeetCode #10
18. **Serialize and Deserialize Binary Tree** - LeetCode #297
19. **Meeting Rooms II** - LeetCode #253
20. **Alien Dictionary** - LeetCode #269

---

## Apple Top 20 Problems

1. **Two Sum** - LeetCode #1
2. **Reverse Integer** - LeetCode #7
3. **Palindrome Number** - LeetCode #9
4. **Valid Parentheses** - LeetCode #20
5. **Best Time to Buy and Sell Stock** - LeetCode #121
6. **Reverse Linked List** - LeetCode #206
7. **Binary Tree Level Order Traversal** - LeetCode #102
8. **Validate Binary Search Tree** - LeetCode #98
9. **Binary Tree Inorder Traversal** - LeetCode #94
10. **Longest Substring Without Repeating Characters** - LeetCode #3
11. **3Sum** - LeetCode #15
12. **Container With Most Water** - LeetCode #11
13. **Remove Nth Node From End of List** - LeetCode #19
14. **Number of Islands** - LeetCode #200
15. **Same Tree** - LeetCode #100
16. **Symmetric Tree** - LeetCode #101
17. **Maximum Depth of Binary Tree** - LeetCode #104
18. **Invert Binary Tree** - LeetCode #226
19. **Balanced Binary Tree** - LeetCode #110
20. **Convert Sorted Array to Binary Search Tree** - LeetCode #108

---

# CORE CODING PATTERNS {#core-patterns}

## Pattern 1: Two Pointers

### Problem: Two Sum
```python
def twoSum(nums: List[int], target: int) -> List[int]:
    """
    Given array of integers, return indices of two numbers that add up to target.
    Assume each input has exactly one solution and can't use same element twice.
    
    Time: O(n), Space: O(n)
    """
    seen = {}
    for i, num in enumerate(nums):
        complement = target - num
        if complement in seen:
            return [seen[complement], i]
        seen[num] = i
    return []

# Test
print(twoSum([2, 7, 11, 15], 9))  # [0, 1]
print(twoSum([3, 2, 4], 6))       # [1, 2]
```

### Problem: Container With Most Water
```python
def maxArea(height: List[int]) -> int:
    """
    Given array representing heights, find two lines that form container with max water.
    
    Greedy two pointer approach:
    - Start with widest container
    - Move the pointer pointing to shorter line inward
    - This can only increase area (moving taller one can't help)
    
    Time: O(n), Space: O(1)
    """
    max_area = 0
    left, right = 0, len(height) - 1
    
    while left < right:
        width = right - left
        current_height = min(height[left], height[right])
        current_area = width * current_height
        max_area = max(max_area, current_area)
        
        # Move pointer pointing to shorter line
        if height[left] < height[right]:
            left += 1
        else:
            right -= 1
    
    return max_area

# Test
print(maxArea([1,8,6,2,5,4,8,3,7]))  # 49
```

### Problem: 3Sum
```python
def threeSum(nums: List[int]) -> List[List[int]]:
    """
    Find all unique triplets that sum to zero.
    
    Approach:
    1. Sort array
    2. Fix one element
    3. Use two pointers to find other two
    4. Skip duplicates
    
    Time: O(nÂ²), Space: O(1) if not counting output
    """
    nums.sort()
    result = []
    n = len(nums)
    
    for i in range(n - 2):
        # Optimization: if positive, no triplet can sum to 0
        if nums[i] > 0:
            break
        
        # Skip duplicates
        if i > 0 and nums[i] == nums[i - 1]:
            continue
        
        # Two sum for remaining elements
        target = -nums[i]
        left, right = i + 1, n - 1
        
        while left < right:
            total = nums[left] + nums[right]
            if total == target:
                result.append([nums[i], nums[left], nums[right]])
                
                # Skip duplicates
                while left < right and nums[left] == nums[left + 1]:
                    left += 1
                while left < right and nums[right] == nums[right - 1]:
                    right -= 1
                
                left += 1
                right -= 1
            elif total < target:
                left += 1
            else:
                right -= 1
    
    return result

# Test
print(threeSum([-1, 0, 1, 2, -1, -4]))  # [[-1, -1, 2], [-1, 0, 1]]
```

---

## Pattern 2: Sliding Window

### Problem: Longest Substring Without Repeating Characters
```python
def lengthOfLongestSubstring(s: str) -> int:
    """
    Find length of longest substring without repeating characters.
    
    Sliding window with character index map:
    - Expand window by moving right pointer
    - When duplicate found, move left pointer past previous occurrence
    
    Time: O(n), Space: O(min(n, charset_size))
    """
    char_index = {}
    max_length = 0
    start = 0
    
    for end, char in enumerate(s):
        if char in char_index and char_index[char] >= start:
            # Move start to position after previous occurrence
            start = char_index[char] + 1
        
        char_index[char] = end
        max_length = max(max_length, end - start + 1)
    
    return max_length

# Test
print(lengthOfLongestSubstring("abcabcbb"))  # 3 ("abc")
print(lengthOfLongestSubstring("bbbbb"))     # 1 ("b")
print(lengthOfLongestSubstring("pwwkew"))    # 3 ("wke")
```

### Problem: Minimum Window Substring
```python
def minWindow(s: str, t: str) -> str:
    """
    Find minimum window substring that contains all characters in t.
    
    Sliding window with frequency maps:
    - Expand right until all characters covered
    - Shrink left to find minimum
    
    Time: O(n + m), Space: O(charset_size)
    """
    if not t or not s:
        return ""
    
    # Dictionary to keep track of required characters
    required = {}
    for char in t:
        required[char] = required.get(char, 0) + 1
    
    # Left and right pointers
    l, r = 0, 0
    
    # formed keeps track of how many unique characters in t
    # are present in current window with desired frequency
    formed = 0
    
    # Dictionary to keep count of all unique characters in current window
    window_counts = {}
    
    # ans tuple of the form (window length, left, right)
    ans = float("inf"), None, None
    
    while r < len(s):
        # Add character from right to window
        char = s[r]
        window_counts[char] = window_counts.get(char, 0) + 1
        
        # If frequency of current character matches required, increment formed
        if char in required and window_counts[char] == required[char]:
            formed += 1
        
        # Try to contract the window until point where it ceases to be 'desirable'
        while l <= r and formed == len(required):
            char = s[l]
            
            # Save the smallest window
            if r - l + 1 < ans[0]:
                ans = (r - l + 1, l, r)
            
            # The character at the position pointed by the left pointer is no longer part of window
            window_counts[char] -= 1
            if char in required and window_counts[char] < required[char]:
                formed -= 1
            
            l += 1
        
        r += 1
    
    return "" if ans[0] == float("inf") else s[ans[1]:ans[2] + 1]

# Test
print(minWindow("ADOBECODEBANC", "ABC"))  # "BANC"
```

### Problem: Sliding Window Maximum
```python
def maxSlidingWindow(nums: List[int], k: int) -> List[int]:
    """
    Find maximum in each sliding window of size k.
    
    Use deque to store indices:
    - Remove indices outside window from front
    - Remove smaller elements from back
    
    Time: O(n), Space: O(k)
    """
    from collections import deque
    
    if not nums or k == 0:
        return []
    
    dq = deque()  # Store indices
    result = []
    
    for i in range(len(nums)):
        # Remove indices outside current window
        while dq and dq[0] < i - k + 1:
            dq.popleft()
        
        # Remove smaller elements from back
        while dq and nums[dq[-1]] < nums[i]:
            dq.pop()
        
        dq.append(i)
        
        # First window can be processed from index k-1
        if i >= k - 1:
            result.append(nums[dq[0]])
    
    return result

# Test
print(maxSlidingWindow([1, 3, -1, -3, 5, 3, 6, 7], 3))
# [3, 3, 5, 5, 6, 7]
```

---

## Pattern 3: Hash Map / Set

### Problem: Valid Anagram
```python
def isAnagram(s: str, t: str) -> bool:
    """
    Determine if two strings are anagrams of each other.
    
    Approaches:
    1. Frequency count with hash map: O(n)
    2. Sorting: O(n log n)
    3. Array (for ASCII): O(n)
    
    Time: O(n), Space: O(1) for ASCII
    """
    if len(s) != len(t):
        return False
    
    # Approach 1: Frequency count
    char_count = {}
    for char in s:
        char_count[char] = char_count.get(char, 0) + 1
    
    for char in t:
        if char not in char_count:
            return False
        char_count[char] -= 1
        if char_count[char] < 0:
            return False
    
    return True

# Alternative using Counter
from collections import Counter
def isAnagram_v2(s: str, t: str) -> bool:
    return Counter(s) == Counter(t)

# Alternative using sorted
def isAnagram_v3(s: str, t: str) -> bool:
    return sorted(s) == sorted(t)

# Test
print(isAnagram("anagram", "nagaram"))  # True
print(isAnagram("rat", "car"))          # False
```

### Problem: Group Anagrams
```python
def groupAnagrams(strs: List[str]) -> List[List[str]]:
    """
    Group strings that are anagrams together.
    
    Key insight: Strings are anagrams if they have same characters.
    Use sorted characters as key in hash map.
    
    Time: O(n * k log k) where n=strings, k=avg length
    Space: O(n * k)
    """
    anagrams = {}
    
    for word in strs:
        # Sort characters to create key (same for all anagrams)
        key = ''.join(sorted(word))
        
        if key not in anagrams:
            anagrams[key] = []
        anagrams[key].append(word)
    
    return list(anagrams.values())

# Test
print(groupAnagrams(["eat", "tea", "ate", "bat", "tab", "cat"]))
# [['eat', 'tea', 'ate'], ['bat', 'tab'], ['cat']]
```

---

## Pattern 4: Dynamic Programming

### Problem: Climbing Stairs
```python
def climbStairs(n: int) -> int:
    """
    You are climbing a staircase with n steps.
    Each time you can climb 1 or 2 steps.
    How many distinct ways can you climb to the top?
    
    Recurrence: dp[i] = dp[i-1] + dp[i-2]
    Base cases: dp[1]=1, dp[2]=2
    
    Time: O(n), Space: O(n) or O(1) with optimization
    """
    if n <= 1:
        return 1
    if n == 2:
        return 2
    
    # Space-optimized: only need previous two values
    prev2, prev1 = 1, 2
    
    for i in range(3, n + 1):
        current = prev1 + prev2
        prev2 = prev1
        prev1 = current
    
    return prev1

# Test
print(climbStairs(2))  # 2
print(climbStairs(3))  # 3
print(climbStairs(4))  # 5
```

### Problem: Longest Increasing Subsequence
```python
def lengthOfLIS(nums: List[int]) -> int:
    """
    Find length of longest increasing subsequence.
    
    Approach 1: DP - O(nÂ²)
    dp[i] = longest increasing subsequence ending at index i
    
    Approach 2: Binary search - O(n log n)
    Maintain array of smallest endings
    
    Time: O(n log n), Space: O(n)
    """
    if not nums:
        return 0
    
    # Binary search approach
    import bisect
    tails = []  # tails[i] = smallest tail of all increasing subsequences of length i+1
    
    for num in nums:
        # Find position where num should be inserted
        pos = bisect.bisect_left(tails, num)
        
        if pos == len(tails):
            tails.append(num)
        else:
            tails[pos] = num
    
    return len(tails)

# Test
print(lengthOfLIS([10, 9, 2, 5, 3, 7, 101, 18]))  # 4 ([2,3,7,101])
```

### Problem: Longest Palindromic Substring
```python
def longestPalindrome(s: str) -> str:
    """
    Find longest palindromic substring.
    
    Approach: Expand around centers
    - For each possible center (single or double char)
    - Expand while characters match
    
    Time: O(nÂ²), Space: O(1)
    """
    if not s:
        return ""
    
    def expand_around_center(left, right):
        while left >= 0 and right < len(s) and s[left] == s[right]:
            left -= 1
            right += 1
        return right - left - 1  # Length of palindrome
    
    start = 0
    max_len = 0
    
    for i in range(len(s)):
        # Odd length palindromes
        len1 = expand_around_center(i, i)
        # Even length palindromes
        len2 = expand_around_center(i, i + 1)
        
        length = max(len1, len2)
        if length > max_len:
            max_len = length
            start = i - (length - 1) // 2
    
    return s[start:start + max_len]

# Test
print(longestPalindrome("babad"))  # "bab" or "aba"
print(longestPalindrome("cbbd"))   # "bb"
```

---

## Pattern 5: Tree Traversal

### Problem: Binary Tree Level Order Traversal
```python
def levelOrder(root: Optional[TreeNode]) -> List[List[int]]:
    """
    Return level-by-level traversal of binary tree.
    
    BFS approach using queue:
    - Add root to queue
    - For each level, process all nodes in queue
    - Add their children for next level
    
    Time: O(n), Space: O(w) where w=max width
    """
    from collections import deque
    
    if not root:
        return []
    
    result = []
    queue = deque([root])
    
    while queue:
        level_size = len(queue)
        current_level = []
        
        # Process all nodes at current level
        for _ in range(level_size):
            node = queue.popleft()
            current_level.append(node.val)
            
            if node.left:
                queue.append(node.left)
            if node.right:
                queue.append(node.right)
        
        result.append(current_level)
    
    return result
```

### Problem: Binary Tree Inorder Traversal
```python
def inorderTraversal(root: Optional[TreeNode]) -> List[int]:
    """
    Return inorder traversal: Left -> Root -> Right
    
    Can be done recursively or iteratively with stack.
    
    Time: O(n), Space: O(h) for recursion stack
    """
    result = []
    
    def dfs(node):
        if not node:
            return
        dfs(node.left)
        result.append(node.val)
        dfs(node.right)
    
    dfs(root)
    return result

# Iterative approach
def inorderTraversal_iterative(root: Optional[TreeNode]) -> List[int]:
    result = []
    stack = []
    current = root
    
    while current or stack:
        # Go to leftmost node
        while current:
            stack.append(current)
            current = current.left
        
        # Current is None, pop from stack
        current = stack.pop()
        result.append(current.val)
        
        # Visit right subtree
        current = current.right
    
    return result
```

### Problem: Lowest Common Ancestor
```python
def lowestCommonAncestor(root: TreeNode, p: TreeNode, q: TreeNode) -> TreeNode:
    """
    Find lowest common ancestor of two nodes p and q in BST.
    
    Key insight for BST:
    - If both p and q < root.val, go left
    - If both p and q > root.val, go right
    - Otherwise, root is LCA
    
    Time: O(h) where h=height, Space: O(1)
    """
    if not root:
        return None
    
    if p.val < root.val and q.val < root.val:
        return lowestCommonAncestor(root.left, p, q)
    elif p.val > root.val and q.val > root.val:
        return lowestCommonAncestor(root.right, p, q)
    else:
        return root

# For general binary tree
def lowestCommonAncestor_general(root: TreeNode, p: TreeNode, q: TreeNode) -> TreeNode:
    """
    For general binary tree (not BST).
    
    Recursively search for p and q:
    - If current node is p or q, return current
    - Recursively search left and right
    - If both subtrees return non-null, current is LCA
    - If only one subtree returns non-null, return that
    """
    if not root or root == p or root == q:
        return root
    
    left = lowestCommonAncestor_general(root.left, p, q)
    right = lowestCommonAncestor_general(root.right, p, q)
    
    if left and right:
        return root
    return left if left else right
```

---

## Pattern 6: Graph (BFS/DFS)

### Problem: Number of Islands
```python
def numIslands(grid: List[List[str]]) -> int:
    """
    Count number of islands (1s) in grid surrounded by water (0s).
    
    DFS approach:
    - For each unvisited 1, start DFS
    - Mark all connected 1s as visited
    - Count number of DFS calls
    
    Time: O(m * n), Space: O(m * n) for visited
    """
    if not grid:
        return 0
    
    count = 0
    visited = set()
    
    def dfs(i, j):
        if (i, j) in visited or i < 0 or i >= len(grid) or j < 0 or j >= len(grid[0]) or grid[i][j] == '0':
            return
        visited.add((i, j))
        # Explore 4 directions
        dfs(i + 1, j)
        dfs(i - 1, j)
        dfs(i, j + 1)
        dfs(i, j - 1)
    
    for i in range(len(grid)):
        for j in range(len(grid[0])):
            if grid[i][j] == '1' and (i, j) not in visited:
                dfs(i, j)
                count += 1
    
    return count

# Test
print(numIslands([
    ["1", "1", "1", "1", "0"],
    ["1", "1", "0", "1", "0"],
    ["1", "1", "0", "0", "0"],
    ["0", "0", "0", "0", "0"]
]))  # 1

print(numIslands([
    ["1", "1", "0", "0", "0"],
    ["1", "1", "0", "0", "0"],
    ["0", "0", "1", "0", "0"],
    ["0", "0", "0", "1", "1"]
]))  # 3
```

### Problem: Course Schedule (Topological Sort)
```python
def canFinish(numCourses: int, prerequisites: List[List[int]]) -> bool:
    """
    Determine if all courses can be finished.
    Prerequisites form a directed graph.
    
    Problem: Detect cycle in directed graph using DFS.
    If cycle exists, can't finish all courses.
    
    States: 0=unvisited, 1=visiting, 2=visited
    
    Time: O(n + e), Space: O(n)
    """
    # Build adjacency list
    graph = [[] for _ in range(numCourses)]
    for course, prereq in prerequisites:
        graph[course].append(prereq)
    
    # 0: unvisited, 1: visiting, 2: visited
    state = [0] * numCourses
    
    def has_cycle(course):
        if state[course] == 1:
            # Cycle detected (currently visiting)
            return True
        if state[course] == 2:
            # Already processed
            return False
        
        state[course] = 1
        for prereq in graph[course]:
            if has_cycle(prereq):
                return True
        state[course] = 2
        return False
    
    for course in range(numCourses):
        if has_cycle(course):
            return False
    return True

# Test
print(canFinish(2, [[1, 0]]))      # True
print(canFinish(2, [[1, 0], [0, 1]]))  # False (cycle)
```

---

## Pattern 7: Linked List

### Problem: Reverse Linked List
```python
def reverseList(head: Optional[ListNode]) -> Optional[ListNode]:
    """
    Reverse a linked list.
    
    Iterative approach:
    - Keep track of previous, current, next nodes
    - Reverse pointer at each step
    
    Time: O(n), Space: O(1)
    """
    prev = None
    current = head
    
    while current:
        # Store next node
        next_temp = current.next
        # Reverse the link
        current.next = prev
        # Move prev and current one step forward
        prev = current
        current = next_temp
    
    return prev

# Recursive approach
def reverseList_recursive(head: Optional[ListNode]) -> Optional[ListNode]:
    if not head or not head.next:
        return head
    
    new_head = reverseList_recursive(head.next)
    head.next.next = head
    head.next = None
    return new_head
```

### Problem: Merge Two Sorted Lists
```python
def mergeTwoLists(list1: Optional[ListNode], list2: Optional[ListNode]) -> Optional[ListNode]:
    """
    Merge two sorted linked lists into one sorted list.
    
    Two pointer approach:
    - Compare nodes from both lists
    - Add smaller one to result
    
    Time: O(n + m), Space: O(1)
    """
    dummy = ListNode(0)
    current = dummy
    
    while list1 and list2:
        if list1.val <= list2.val:
            current.next = list1
            list1 = list1.next
        else:
            current.next = list2
            list2 = list2.next
        current = current.next
    
    # Attach remaining nodes
    current.next = list1 if list1 else list2
    return dummy.next
```

---

## Pattern 8: Backtracking

### Problem: Permutations
```python
def permute(nums: List[int]) -> List[List[int]]:
    """
    Generate all permutations of numbers.
    
    Backtracking approach:
    - Build permutation one element at a time
    - At each step, try all remaining elements
    - Backtrack when permutation complete
    
    Time: O(n * n!), Space: O(n)
    """
    result = []
    
    def backtrack(current):
        # Base case: permutation complete
        if len(current) == len(nums):
            result.append(current[:])
            return
        
        for num in nums:
            if num not in current:
                current.append(num)
                backtrack(current)
                current.pop()
    
    backtrack([])
    return result

# Alternative with indices
def permute_v2(nums: List[int]) -> List[List[int]]:
    result = []
    
    def backtrack(first):
        if first == len(nums):
            result.append(nums[:])
        
        for i in range(first, len(nums)):
            nums[first], nums[i] = nums[i], nums[first]
            backtrack(first + 1)
            nums[first], nums[i] = nums[i], nums[first]
    
    backtrack(0)
    return result

# Test
print(permute([1, 2, 3]))
# [[1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1]]
```

### Problem: N-Queens
```python
def solveNQueens(n: int) -> List[List[str]]:
    """
    Place n queens on nÃ—n chessboard such that no two attack each other.
    
    Backtracking:
    - Place queens row by row
    - Check if placement is valid (no conflicts)
    - Backtrack if invalid
    
    Time: O(n!), Space: O(nÂ²)
    """
    result = []
    
    def is_safe(board, row, col):
        # Check column
        for i in range(row):
            if board[i][col] == 'Q':
                return False
        
        # Check upper left diagonal
        i, j = row - 1, col - 1
        while i >= 0 and j >= 0:
            if board[i][j] == 'Q':
                return False
            i -= 1
            j -= 1
        
        # Check upper right diagonal
        i, j = row - 1, col + 1
        while i >= 0 and j < n:
            if board[i][j] == 'Q':
                return False
            i -= 1
            j += 1
        
        return True
    
    def backtrack(board, row):
        if row == n:
            result.append([''.join(row) for row in board])
            return
        
        for col in range(n):
            if is_safe(board, row, col):
                board[row][col] = 'Q'
                backtrack(board, row + 1)
                board[row][col] = '.'
    
    board = [['.' for _ in range(n)] for _ in range(n)]
    backtrack(board, 0)
    return result
```

---

# ESSENTIAL DATA STRUCTURE PROBLEMS {#essential-ds}

## Stack & Queue Problems

### Problem: Valid Parentheses
```python
def isValid(s: str) -> bool:
    """
    Determine if string contains valid parentheses combinations.
    
    Stack approach:
    - Push opening brackets
    - Pop and match on closing brackets
    
    Time: O(n), Space: O(n)
    """
    stack = []
    pairs = {'(': ')', '[': ']', '{': '}'}
    
    for char in s:
        if char in pairs:
            stack.append(char)
        else:
            if not stack or pairs[stack.pop()] != char:
                return False
    
    return len(stack) == 0

# Test
print(isValid("()"))      # True
print(isValid("()[]{"))   # False
```

### Problem: Min Stack
```python
class MinStack:
    """
    Design stack that supports push, pop, top, and getting minimum in O(1).
    
    Approach: Maintain two stacks
    - One for values
    - One for minimums
    
    Space: O(n), Time: O(1) for all operations
    """
    def __init__(self):
        self.stack = []
        self.min_stack = []
    
    def push(self, val: int) -> None:
        self.stack.append(val)
        if not self.min_stack or val <= self.min_stack[-1]:
            self.min_stack.append(val)
    
    def pop(self) -> None:
        if self.stack.pop() == self.min_stack[-1]:
            self.min_stack.pop()
    
    def top(self) -> int:
        return self.stack[-1]
    
    def getMin(self) -> int:
        return self.min_stack[-1]

# Test
min_stack = MinStack()
min_stack.push(-2)
min_stack.push(0)
min_stack.push(-3)
print(min_stack.getMin())  # -3
min_stack.pop()
print(min_stack.top())     # 0
print(min_stack.getMin())  # -2
```

---

## Hash Table Problems

### Problem: Longest Substring with At Most K Distinct Characters
```python
def lengthOfLongestSubstringKDistinct(s: str, k: int) -> int:
    """
    Find length of longest substring with at most k distinct characters.
    
    Sliding window with frequency map:
    - Expand window by moving right
    - When more than k distinct chars, shrink from left
    
    Time: O(n), Space: O(k)
    """
    if not s or k == 0:
        return 0
    
    char_count = {}
    max_length = 0
    left = 0
    
    for right in range(len(s)):
        # Add character to window
        char = s[right]
        char_count[char] = char_count.get(char, 0) + 1
        
        # Shrink window if more than k distinct characters
        while len(char_count) > k:
            left_char = s[left]
            char_count[left_char] -= 1
            if char_count[left_char] == 0:
                del char_count[left_char]
            left += 1
        
        max_length = max(max_length, right - left + 1)
    
    return max_length

# Test
print(lengthOfLongestSubstringKDistinct("eceba", 2))  # 3 ("ece")
```

---

## Heap Problems

### Problem: K Largest Elements
```python
def findKlargest(nums: List[int], k: int) -> List[int]:
    """
    Find k largest elements in array.
    
    Heap approach: Use min-heap of size k
    Time: O(n log k), Space: O(k)
    
    Alternative: Sort O(n log n)
    Alternative: QuickSelect O(n) average
    """
    import heapq
    
    # Min-heap approach: keep k largest
    if k >= len(nums):
        return sorted(nums, reverse=True)
    
    heap = nums[:k]
    heapq.heapify(heap)
    
    for num in nums[k:]:
        if num > heap[0]:
            heapq.heapreplace(heap, num)
    
    return sorted(heap, reverse=True)

# Test
print(findKlargest([3, 2, 1, 5, 6, 4], 2))  # [6, 5]
```

---

## Trie Problems

### Problem: Implement Trie
```python
class TrieNode:
    def __init__(self):
        self.children = {}
        self.is_end = False

class Trie:
    """
    Prefix tree for efficient string searching.
    
    Insert: O(m) where m=word length
    Search: O(m)
    StartsWith: O(m)
    Space: O(ALPHABET_SIZE * N * M) where N=number of words, M=avg length
    """
    def __init__(self):
        self.root = TrieNode()
    
    def insert(self, word: str) -> None:
        node = self.root
        for char in word:
            if char not in node.children:
                node.children[char] = TrieNode()
            node = node.children[char]
        node.is_end = True
    
    def search(self, word: str) -> bool:
        node = self.root
        for char in word:
            if char not in node.children:
                return False
            node = node.children[char]
        return node.is_end
    
    def startsWith(self, prefix: str) -> bool:
        node = self.root
        for char in prefix:
            if char not in node.children:
                return False
            node = node.children[char]
        return True

# Test
trie = Trie()
trie.insert("apple")
print(trie.search("apple"))      # True
print(trie.search("app"))        # False
print(trie.startsWith("app"))    # True
```

---

# ALGORITHM MASTERY PROBLEMS {#algorithms}

## Sorting & Searching

### Problem: Binary Search
```python
def search(nums: List[int], target: int) -> int:
    """
    Classic binary search. Return index if found, else -1.
    
    Time: O(log n), Space: O(1)
    """
    left, right = 0, len(nums) - 1
    
    while left <= right:
        mid = (left + right) // 2
        if nums[mid] == target:
            return mid
        elif nums[mid] < target:
            left = mid + 1
        else:
            right = mid - 1
    
    return -1

# Test
print(search([-1, 0, 3, 5, 9, 12], 9))  # 4
print(search([-1, 0, 3, 5, 9, 12], 13)) # -1
```

### Problem: Search in Rotated Sorted Array
```python
def search_rotated(nums: List[int], target: int) -> int:
    """
    Search in rotated sorted array.
    
    Key insight: One half is always sorted.
    Check which half is sorted, then decide where to search.
    
    Time: O(log n), Space: O(1)
    """
    left, right = 0, len(nums) - 1
    
    while left <= right:
        mid = (left + right) // 2
        if nums[mid] == target:
            return mid
        
        # Determine which half is sorted
        if nums[left] <= nums[mid]:
            # Left half is sorted
            if nums[left] <= target < nums[mid]:
                right = mid - 1
            else:
                left = mid + 1
        else:
            # Right half is sorted
            if nums[mid] < target <= nums[right]:
                left = mid + 1
            else:
                right = mid - 1
    
    return -1

# Test
print(search_rotated([4, 5, 6, 7, 0, 1, 2], 0))  # 4
```

---

## Greedy Algorithms

### Problem: Jump Game
```python
def canJump(nums: List[int]) -> bool:
    """
    Determine if you can reach the last index.
    From each position i, you can jump at most nums[i] steps forward.
    
    Greedy: Track farthest reachable index.
    
    Time: O(n), Space: O(1)
    """
    farthest = 0
    
    for i in range(len(nums)):
        if i > farthest:
            # Can't reach this index
            return False
        farthest = max(farthest, i + nums[i])
        if farthest >= len(nums) - 1:
            return True
    
    return False

# Test
print(canJump([2, 3, 1, 1, 4]))  # True
print(canJump([3, 2, 1, 0, 4]))  # False
```

### Problem: Gas Station
```python
def canCompleteCircuit(gas: List[int], cost: List[int]) -> int:
    """
    Find starting gas station where you can complete circuit.
    Return index, else -1.
    
    Key insight: If total gas >= total cost, solution exists.
    Find starting point where tank never becomes negative.
    
    Time: O(n), Space: O(1)
    """
    if sum(gas) < sum(cost):
        return -1
    
    tank = 0
    start = 0
    
    for i in range(len(gas)):
        tank += gas[i] - cost[i]
        if tank < 0:
            start = i + 1
            tank = 0
    
    return start

# Test
print(canCompleteCircuit([1, 2, 3, 4, 5], [3, 4, 5, 1, 2]))  # 3
```

---

# SYSTEM DESIGN PATTERNS {#system-design}

## Problem: LRU Cache
```python
class LRUCache:
    """
    Least Recently Used Cache.
    
    Get: O(1)
    Put: O(1)
    Space: O(capacity)
    
    Use OrderedDict to maintain insertion order.
    """
    def __init__(self, capacity: int):
        self.capacity = capacity
        self.cache = {}
        self.order = []
    
    def get(self, key: int) -> int:
        if key not in self.cache:
            return -1
        
        # Move to end (most recently used)
        self.order.remove(key)
        self.order.append(key)
        return self.cache[key]
    
    def put(self, key: int, value: int) -> None:
        if key in self.cache:
            self.order.remove(key)
        elif len(self.cache) == self.capacity:
            # Remove least recently used
            lru_key = self.order.pop(0)
            del self.cache[lru_key]
        
        self.cache[key] = value
        self.order.append(key)

# Alternative using OrderedDict
from collections import OrderedDict

class LRUCache_v2:
    def __init__(self, capacity: int):
        self.cache = OrderedDict()
        self.capacity = capacity
    
    def get(self, key: int) -> int:
        if key not in self.cache:
            return -1
        self.cache.move_to_end(key)
        return self.cache[key]
    
    def put(self, key: int, value: int) -> None:
        if key in self.cache:
            self.cache.move_to_end(key)
        self.cache[key] = value
        if len(self.cache) > self.capacity:
            self.cache.popitem(last=False)

# Test
lru = LRUCache(2)
lru.put(1, 1)
lru.put(2, 2)
print(lru.get(1))  # 1
lru.put(3, 3)
print(lru.get(2))  # -1 (evicted)
```

---

## Problem: Serialize and Deserialize Binary Tree
```python
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

class Codec:
    """
    Serialize binary tree to string and deserialize back.
    
    Uses pre-order traversal with null markers.
    
    Time: O(n), Space: O(n)
    """
    
    def serialize(self, root):
        """Encodes tree to single string."""
        result = []
        
        def dfs(node):
            if not node:
                result.append('null')
                return
            result.append(str(node.val))
            dfs(node.left)
            dfs(node.right)
        
        dfs(root)
        return ','.join(result)
    
    def deserialize(self, data):
        """Decodes string to binary tree."""
        values = data.split(',')
        self.index = 0
        
        def dfs():
            if self.index >= len(values) or values[self.index] == 'null':
                self.index += 1
                return None
            
            node = TreeNode(int(values[self.index]))
            self.index += 1
            node.left = dfs()
            node.right = dfs()
            return node
        
        return dfs()
```

---

# LEETCODE HARD PROBLEMS {#leetcode-hard}

## Problem: Regular Expression Matching
```python
def isMatch(s: str, p: str) -> bool:
    """
    Implement regular expression matcher with '.' (any char) and '*' (0 or more).
    
    Dynamic programming:
    dp[i][j] = s[0...i-1] matches p[0...j-1]
    
    Time: O(m * n), Space: O(m * n)
    """
    m, n = len(s), len(p)
    dp = [[False] * (n + 1) for _ in range(m + 1)]
    dp[0][0] = True
    
    # Handle patterns like a*, a*b*, a*b*c* (empty string matches)
    for j in range(2, n + 1):
        if p[j - 1] == '*':
            dp[0][j] = dp[0][j - 2]
    
    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if p[j - 1] == '*':
                # Match 0 of previous char or match 1+ of previous char
                dp[i][j] = dp[i][j - 2]  # Match 0
                if p[j - 2] == s[i - 1] or p[j - 2] == '.':
                    dp[i][j] = dp[i][j] or dp[i - 1][j]
            elif p[j - 1] == '.' or p[j - 1] == s[i - 1]:
                dp[i][j] = dp[i - 1][j - 1]
    
    return dp[m][n]

# Test
print(isMatch("aa", "a"))       # False
print(isMatch("aa", "a*"))      # True
print(isMatch("ab", ".*"))      # True
```

---

## Problem: Trapping Rain Water
```python
def trap(height: List[int]) -> int:
    """
    Calculate water trapped between bars of different heights.
    
    Two pointer approach:
    - Water trapped = min(left_max, right_max) - height[i]
    - Use two pointers moving inward
    
    Time: O(n), Space: O(1)
    """
    if not height:
        return 0
    
    left, right = 0, len(height) - 1
    water = 0
    left_max, right_max = 0, 0
    
    while left < right:
        if height[left] < height[right]:
            if height[left] >= left_max:
                left_max = height[left]
            else:
                water += left_max - height[left]
            left += 1
        else:
            if height[right] >= right_max:
                right_max = height[right]
            else:
                water += right_max - height[right]
            right -= 1
    
    return water

# Test
print(trap([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]))  # 6
```

---

## Problem: Median of Two Sorted Arrays
```python
def findMedianSortedArrays(nums1: List[int], nums2: List[int]) -> float:
    """
    Find median of two sorted arrays.
    
    Binary search approach:
    - Partition both arrays
    - Ensure left partition has half of all elements
    
    Time: O(log(min(m, n))), Space: O(1)
    """
    if len(nums1) > len(nums2):
        return findMedianSortedArrays(nums2, nums1)
    
    m, n = len(nums1), len(nums2)
    left, right = 0, m
    
    while left <= right:
        partition1 = (left + right) // 2
        partition2 = (m + n + 1) // 2 - partition1
        
        left_max1 = float('-inf') if partition1 == 0 else nums1[partition1 - 1]
        right_min1 = float('inf') if partition1 == m else nums1[partition1]
        
        left_max2 = float('-inf') if partition2 == 0 else nums2[partition2 - 1]
        right_min2 = float('inf') if partition2 == n else nums2[partition2]
        
        if left_max1 <= right_min2 and left_max2 <= right_min1:
            if (m + n) % 2 == 0:
                return (max(left_max1, left_max2) + min(right_min1, right_min2)) / 2
            else:
                return max(left_max1, left_max2)
        elif left_max1 > right_min2:
            right = partition1 - 1
        else:
            left = partition1 + 1
    
    return -1
```

---

# REAL INTERVIEW QUESTIONS {#real-questions}

## Google Interview Questions

### Problem: Meeting Rooms II
```python
def minMeetingRooms(intervals: List[List[int]]) -> int:
    """
    Find minimum number of rooms needed for all meetings.
    
    Sort by start time, track max overlapping meetings.
    
    Time: O(n log n), Space: O(n)
    """
    if not intervals:
        return 0
    
    start_times = sorted([interval[0] for interval in intervals])
    end_times = sorted([interval[1] for interval in intervals])
    
    rooms = 0
    end_index = 0
    
    for start in start_times:
        if start < end_times[end_index]:
            rooms += 1
        else:
            end_index += 1
    
    return rooms

# Test
print(minMeetingRooms([[0, 30], [5, 10], [15, 20]]))  # 2
print(minMeetingRooms([[7, 10], [2, 4]]))  # 1
```

### Problem: Alien Dictionary
```python
def alienOrder(words: List[str]) -> str:
    """
    Find alien dictionary order from sorted list of words.
    
    Build graph from character ordering, topological sort.
    
    Time: O(n * m), Space: O(1) for 26 chars max
    """
    from collections import defaultdict, deque
    
    graph = defaultdict(set)
    in_degree = defaultdict(int)
    
    # Initialize all characters
    for word in words:
        for char in word:
            in_degree[char]
    
    # Build graph
    for i in range(len(words) - 1):
        word1, word2 = words[i], words[i + 1]
        min_len = min(len(word1), len(word2))
        
        for j in range(min_len):
            if word1[j] != word2[j]:
                if word2[j] not in graph[word1[j]]:
                    graph[word1[j]].add(word2[j])
                    in_degree[word2[j]] += 1
                break
        else:
            # word1 is prefix of word2, invalid
            if len(word1) > len(word2):
                return ""
    
    # Topological sort
    queue = deque([char for char in in_degree if in_degree[char] == 0])
    result = []
    
    while queue:
        char = queue.popleft()
        result.append(char)
        
        for neighbor in graph[char]:
            in_degree[neighbor] -= 1
            if in_degree[neighbor] == 0:
                queue.append(neighbor)
    
    return "".join(result) if len(result) == len(in_degree) else ""
```

---

## Amazon Interview Questions

### Problem: Pacific Atlantic Water Flow
```python
def pacificAtlantic(heights: List[List[int]]) -> List[List[int]]:
    """
    Find cells from which water can flow to both oceans.
    
    Reverse DFS: Start from ocean edges, find what can reach there.
    
    Time: O(m * n), Space: O(m * n)
    """
    if not heights or not heights[0]:
        return []
    
    m, n = len(heights), len(heights[0])
    pacific = set()
    atlantic = set()
    
    def dfs(r, c, visited, prev_height):
        if (r, c) in visited or r < 0 or r >= m or c < 0 or c >= n or heights[r][c] < prev_height:
            return
        
        visited.add((r, c))
        
        dfs(r + 1, c, visited, heights[r][c])
        dfs(r - 1, c, visited, heights[r][c])
        dfs(r, c + 1, visited, heights[r][c])
        dfs(r, c - 1, visited, heights[r][c])
    
    # DFS from pacific (top, left)
    for i in range(m):
        dfs(i, 0, pacific, heights[i][0])
    for j in range(n):
        dfs(0, j, pacific, heights[0][j])
    
    # DFS from atlantic (bottom, right)
    for i in range(m):
        dfs(i, n - 1, atlantic, heights[i][n - 1])
    for j in range(n):
        dfs(m - 1, j, atlantic, heights[m - 1][j])
    
    return list(pacific & atlantic)
```

---

# PRACTICE SCHEDULE {#practice-schedule}

## 4-Week Intensive Interview Preparation

### Week 1: Core Patterns & Fundamentals

**Days 1-2: Two Pointers & Arrays (10 problems)**
- Two Sum
- Container With Most Water
- 3Sum
- Merge Sorted Array
- Remove Duplicates
- Move Zeroes
- Rotate Array
- Trap Rain Water
- Best Time to Buy Stock
- Maximum Product Subarray

**Days 3-4: Strings (8 problems)**
- Longest Substring Without Repeating Characters
- Longest Palindromic Substring
- String to Integer (atoi)
- Reverse String
- Valid Parentheses
- Multiply Strings
- Next Permutation
- Word Break

**Days 5-7: Hash Maps/Sets (7 problems)**
- Valid Anagram
- Group Anagrams
- Isomorphic Strings
- Word Pattern
- First Unique Character
- Intersection of Two Arrays
- Happy Number

---

### Week 2: Data Structures

**Days 1-3: Linked Lists (8 problems)**
- Reverse Linked List
- Merge Two Sorted Lists
- Merge k Sorted Lists
- Swap Nodes in Pairs
- Palindrome Linked List
- Cycle Detection
- Remove Nth Node From End
- Copy List with Random Pointer

**Days 4-5: Stacks & Queues (6 problems)**
- Valid Parentheses
- Min Stack
- Evaluate Reverse Polish Notation
- Implement Queue Using Stacks
- Trapping Rain Water
- Sliding Window Maximum

**Days 6-7: Trees (9 problems)**
- Binary Tree Level Order Traversal
- Binary Tree Inorder Traversal
- Lowest Common Ancestor
- Validate Binary Search Tree
- Balanced Binary Tree
- Symmetric Tree
- Path Sum
- Maximum Path Sum
- Binary Tree to Linked List

---

### Week 3: Algorithms

**Days 1-2: Binary Search (6 problems)**
- Binary Search
- Search in Rotated Sorted Array
- Find First and Last Position
- Search in 2D Matrix
- Median of Two Sorted Arrays
- Peak Element

**Days 3-4: Dynamic Programming (8 problems)**
- Climbing Stairs
- House Robber
- Longest Increasing Subsequence
- Coin Change
- Longest Common Subsequence
- Decode Ways
- Regular Expression Matching
- Edit Distance

**Days 5-7: Graphs & Backtracking (10 problems)**
- Number of Islands
- Course Schedule
- Course Schedule II
- Word Ladder
- Word Ladder II
- Alien Dictionary
- Permutations
- Combinations
- N-Queens
- Subsets

---

### Week 4: Advanced & System Design

**Days 1-2: Design Problems (5 problems)**
- LRU Cache
- Min Stack
- Serialize/Deserialize Binary Tree
- Design Twitter
- Implement Trie

**Days 3-5: Hard Problems (8 problems)**
- Trapping Rain Water II
- Merge k Sorted Lists
- Word Break II
- Palindrome Partitioning II
- Regular Expression Matching
- Wildcard Matching
- Minimum Window Substring
- Sliding Window Maximum

**Days 6-7: Full Mock Interviews**
- Timed problems (1.5 hours)
- Mix of all categories
- Explain solutions verbally

---

## Daily Study Format

### 60-90 Minute Session
```
1. Read Problem (10 min)
   - Understand requirements
   - Identify constraints
   - Think of approaches

2. Code Solution (30 min)
   - Implement without hints
   - Test with examples
   - Handle edge cases

3. Optimize (15 min)
   - Improve time complexity
   - Reduce space complexity
   - Code cleanup

4. Review Solutions (15 min)
   - Compare with optimal
   - Learn new approaches
   - Note patterns

5. Explain (10 min)
   - Explain solution verbally
   - Discuss tradeoffs
   - Practice communication
```

---

## Interview Day Strategy

### Before Interview
- Review cheat sheet (30 min)
- Solve 2 problems (1 hour)
- Review complexity analysis (15 min)
- Rest and breathe (30 min)

### During Interview
1. **Listen (2 min)** - Clarify problem
2. **Discuss (3 min)** - Talk through approach
3. **Code (10 min)** - Write clean code
4. **Test (5 min)** - Verify with examples
5. **Optimize (5 min)** - Discuss improvements

### Communication Tips
- "Let me break down the problem..."
- "I see two approaches here..."
- "Let me trace through this example..."
- "The time complexity is O(...) because..."
- "I could optimize this by..."
- "Are there any edge cases I missed?"

---

## Complexity Cheat Sheet

### Time Complexity
- O(1): Array access, hash lookup, stack push/pop
- O(log n): Binary search, balanced BST operations
- O(n): Linear search, single loop
- O(n log n): Sorting (merge, quick, heap), divide & conquer
- O(nÂ²): Nested loops, bubble/insertion/selection sort
- O(2â¿): Subsets, permutations, exponential
- O(n!): All permutations

### Space Complexity
- O(1): Constant extra space
- O(n): Array, linked list, hash map, recursive stack
- O(n log n): Sorting
- O(nÂ²): 2D array/matrix
- O(2â¿): Storing all subsets

---

## Key Success Factors

1. **Practice Consistently** - Daily coding, even 30 minutes
2. **Understand Patterns** - Not just memorize solutions
3. **Communicate Clearly** - Explain your thinking
4. **Handle Edge Cases** - Empty input, single element, large input
5. **Optimize Always** - Better solution > Faster coding
6. **Mock Interview** - Simulate real interview pressure
7. **Review Mistakes** - Learn from every problem

---

## Resources for Additional Learning

1. **LeetCode Premium** - Most updated problems, company-specific
2. **GeeksforGeeks** - Detailed explanations
3. **InterviewBit** - Curated interview problems
4. **YouTube Channels**:
   - NeetCode (excellent explanations)
   - Abdul Bari (algorithm fundamentals)
   - Striver (problem-solving approach)
5. **Books**:
   - Cracking the Coding Interview
   - Elements of Programming Interviews

---

## Expected Timeline to Interview-Ready

**Current Level â†’ Interview-Ready:**

- **Beginner** (0-50 problems): 6-8 weeks of consistent daily practice
- **Intermediate** (50-150 problems): 4-6 weeks to solidify
- **Advanced** (150+ problems): 2-4 weeks for edge case mastery

**For FAANG companies:** Master at least 150-200 problems across all categories.

---

**YOU'VE GOT THIS! ðŸ’ª** 

Every problem solved is a step closer to landing your dream job at a top tech company. Focus on understanding patterns, not memorizing solutions. Practice consistently, communicate clearly, and you'll be ready for any technical interview!

ðŸš€ Start today. Your future self will thank you.

