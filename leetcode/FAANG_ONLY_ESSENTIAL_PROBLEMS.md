# üéØ FAANG-ONLY INTERVIEW MASTERY GUIDE

**Exclusively Top Tech Company Problems - Google, Amazon, Facebook, Microsoft, Apple**

---

## TABLE OF CONTENTS

1. [Most Frequently Asked Problems](#most-frequent)
2. [Google Must-Know Problems](#google)
3. [Amazon Must-Know Problems](#amazon)
4. [Facebook/Meta Must-Know Problems](#facebook)
5. [Microsoft Must-Know Problems](#microsoft)
6. [Apple Must-Know Problems](#apple)
7. [Pattern-Based Organization](#patterns)
8. [Interview Strategy](#strategy)

---

# MOST FREQUENTLY ASKED PROBLEMS {#most-frequent}

## Top 50 Problems Across FAANG (Must Master)

### Arrays & Strings (12 problems)
1. **Two Sum** ‚≠ê (Asked by: Google, Amazon, Facebook, Microsoft, Apple)
2. **Best Time to Buy and Sell Stock** (Amazon, Microsoft, Apple)
3. **Longest Substring Without Repeating Characters** (Google, Facebook, Microsoft)
4. **Container With Most Water** (Google, Facebook, Microsoft)
5. **3Sum** (Google, Facebook, Microsoft)
6. **Merge Intervals** (Google, Amazon, Facebook)
7. **Trapping Rain Water** (Google, Amazon, Microsoft)
8. **Longest Palindromic Substring** (Google, Facebook, Microsoft)
9. **Minimum Window Substring** (Google, Amazon, Facebook)
10. **Valid Parentheses** (Google, Amazon, Facebook, Microsoft, Apple)
11. **Group Anagrams** (Google, Facebook, Amazon)
12. **Rotate Array** (Amazon, Microsoft, Apple)

### Linked Lists (5 problems)
13. **Reverse Linked List** ‚≠ê (All 5 companies)
14. **Merge Two Sorted Lists** (Amazon, Microsoft, Apple)
15. **Merge k Sorted Lists** (Google, Amazon, Facebook, Microsoft)
16. **Palindrome Linked List** (Amazon, Facebook, Microsoft)
17. **Remove Nth Node From End** (Amazon, Microsoft, Apple)

### Trees (10 problems)
18. **Binary Tree Level Order Traversal** ‚≠ê (All 5 companies)
19. **Lowest Common Ancestor** (Google, Apple, Facebook)
20. **Binary Tree Inorder Traversal** (Amazon, Microsoft, Apple)
21. **Validate Binary Search Tree** (Amazon, Microsoft, Apple)
22. **Binary Tree Path Sum** (Google, Amazon, Facebook)
23. **Maximum Path Sum** (Google, Amazon, Facebook, Microsoft)
24. **Serialize and Deserialize Binary Tree** (Google, Facebook, Microsoft)
25. **Balanced Binary Tree** (Amazon, Microsoft, Apple)
26. **Invert Binary Tree** (Apple, Amazon, Facebook)
27. **Closest Binary Search Tree Value** (Google, Amazon, Microsoft)

### Hash Maps & Sets (6 problems)
28. **Valid Anagram** (Google, Amazon, Facebook)
29. **Contains Duplicate** (Google, Amazon, Facebook, Microsoft, Apple)
30. **Longest Consecutive Sequence** (Google, Amazon, Facebook, Microsoft)
31. **Majority Element** (Amazon, Google, Microsoft)
32. **Intersection of Two Arrays** (Google, Amazon, Microsoft, Apple)
33. **Happy Number** (Google, Amazon, Facebook)

### Dynamic Programming (8 problems)
34. **Climbing Stairs** (Amazon, Microsoft, Apple)
35. **House Robber** (Google, Amazon, Facebook, Microsoft)
36. **Coin Change** (Google, Amazon, Facebook)
37. **Longest Increasing Subsequence** (Google, Facebook, Microsoft, Amazon)
38. **Edit Distance** (Google, Amazon, Facebook, Microsoft)
39. **Decode Ways** (Google, Amazon, Facebook)
40. **Regular Expression Matching** (Google, Facebook, Microsoft)
41. **Word Break** (Google, Amazon, Facebook)

### Graph & BFS/DFS (7 problems)
42. **Number of Islands** ‚≠ê (All 5 companies)
43. **Course Schedule** (Google, Amazon, Facebook, Microsoft)
44. **Course Schedule II** (Google, Amazon, Facebook)
45. **Word Ladder** (Google, Amazon, Facebook, Microsoft)
46. **Clone Graph** (Google, Facebook, Amazon, Microsoft)
47. **Pacific Atlantic Water Flow** (Amazon, Google, Facebook)
48. **Rotting Oranges** (Amazon, Google, Facebook, Microsoft)

### Stack & Design (2 problems)
49. **LRU Cache** ‚≠ê (Google, Amazon, Facebook, Microsoft, Apple)
50. **Min Stack** (Google, Amazon, Facebook, Microsoft, Apple)

---

# GOOGLE MUST-KNOW PROBLEMS {#google}

## Top 25 Problems (In Order of Frequency)

### Tier 1: Most Asked (Appear 30%+ of interviews)
1. **Longest Substring Without Repeating Characters** - LeetCode #3
2. **Container With Most Water** - LeetCode #11
3. **Trapping Rain Water** - LeetCode #42
4. **LRU Cache** - LeetCode #146
5. **Sliding Window Maximum** - LeetCode #239

### Tier 2: Frequently Asked (15-30% of interviews)
6. **Two Sum** - LeetCode #1
7. **3Sum** - LeetCode #15
8. **Merge Intervals** - LeetCode #56
9. **Binary Tree Level Order Traversal** - LeetCode #102
10. **Lowest Common Ancestor** - LeetCode #236
11. **Number of Islands** - LeetCode #200
12. **Course Schedule II** - LeetCode #210
13. **Minimum Window Substring** - LeetCode #76
14. **Median of Two Sorted Arrays** - LeetCode #4
15. **Regular Expression Matching** - LeetCode #10

### Tier 3: Asked Regularly (5-15% of interviews)
16. **Word Ladder** - LeetCode #127
17. **Word Ladder II** - LeetCode #126
18. **Serialize and Deserialize Binary Tree** - LeetCode #297
19. **Alien Dictionary** - LeetCode #269
20. **Meeting Rooms II** - LeetCode #253
21. **Wildcard Matching** - LeetCode #44
22. **Maximum Subarray** - LeetCode #53
23. **Longest Increasing Subsequence** - LeetCode #300
24. **Skyline Problem** - LeetCode #218
25. **Design Search Autocomplete System** - LeetCode #642

---

# AMAZON MUST-KNOW PROBLEMS {#amazon}

## Top 25 Problems (In Order of Frequency)

### Tier 1: Most Asked (30%+ of interviews)
1. **Two Sum** - LeetCode #1
2. **Best Time to Buy and Sell Stock** - LeetCode #121
3. **Merge Intervals** - LeetCode #56
4. **Number of Islands** - LeetCode #200
5. **LRU Cache** - LeetCode #146

### Tier 2: Frequently Asked (15-30% of interviews)
6. **Reverse Linked List** - LeetCode #206
7. **Merge k Sorted Lists** - LeetCode #23
8. **Binary Tree Level Order Traversal** - LeetCode #102
9. **Longest Substring Without Repeating Characters** - LeetCode #3
10. **Meeting Rooms II** - LeetCode #253
11. **Rotate Array** - LeetCode #189
12. **Search in Rotated Sorted Array** - LeetCode #33
13. **Pacific Atlantic Water Flow** - LeetCode #417
14. **Word Ladder** - LeetCode #127
15. **Coin Change** - LeetCode #322

### Tier 3: Asked Regularly (5-15% of interviews)
16. **House Robber** - LeetCode #198
17. **Longest Palindromic Substring** - LeetCode #5
18. **Valid Parentheses** - LeetCode #20
19. **Container With Most Water** - LeetCode #11
20. **Validate Binary Search Tree** - LeetCode #98
21. **Decode Ways** - LeetCode #91
22. **Edit Distance** - LeetCode #72
23. **Palindrome Linked List** - LeetCode #234
24. **Maximum Path Sum** - LeetCode #124
25. **Trapping Rain Water** - LeetCode #42

---

# FACEBOOK/META MUST-KNOW PROBLEMS {#facebook}

## Top 25 Problems (In Order of Frequency)

### Tier 1: Most Asked (30%+ of interviews)
1. **Two Sum** - LeetCode #1
2. **Valid Parentheses** - LeetCode #20
3. **Longest Substring Without Repeating Characters** - LeetCode #3
4. **Merge k Sorted Lists** - LeetCode #23
5. **Number of Islands** - LeetCode #200

### Tier 2: Frequently Asked (15-30% of interviews)
6. **Reverse Linked List** - LeetCode #206
7. **3Sum** - LeetCode #15
8. **Merge Intervals** - LeetCode #56
9. **Container With Most Water** - LeetCode #11
10. **Group Anagrams** - LeetCode #49
11. **Binary Tree Level Order Traversal** - LeetCode #102
12. **Word Break II** - LeetCode #140
13. **Permutations** - LeetCode #46
14. **LRU Cache** - LeetCode #146
15. **Rotting Oranges** - LeetCode #994

### Tier 3: Asked Regularly (5-15% of interviews)
16. **Lowest Common Ancestor** - LeetCode #236
17. **Flatten Nested List Iterator** - LeetCode #341
18. **Serialize and Deserialize Binary Tree** - LeetCode #297
19. **Trapping Rain Water** - LeetCode #42
20. **Palindrome Linked List** - LeetCode #234
21. **Regular Expression Matching** - LeetCode #10
22. **House Robber** - LeetCode #198
23. **Maximum Path Sum** - LeetCode #124
24. **Minimum Window Substring** - LeetCode #76
25. **Combinations** - LeetCode #77

---

# MICROSOFT MUST-KNOW PROBLEMS {#microsoft}

## Top 20 Problems (In Order of Frequency)

### Tier 1: Most Asked (30%+ of interviews)
1. **Two Sum** - LeetCode #1
2. **Valid Parentheses** - LeetCode #20
3. **Reverse Linked List** - LeetCode #206
4. **Best Time to Buy and Sell Stock** - LeetCode #121
5. **Binary Tree Level Order Traversal** - LeetCode #102

### Tier 2: Frequently Asked (15-30% of interviews)
6. **Longest Substring Without Repeating Characters** - LeetCode #3
7. **3Sum** - LeetCode #15
8. **Merge k Sorted Lists** - LeetCode #23
9. **Validate Binary Search Tree** - LeetCode #98
10. **Course Schedule II** - LeetCode #210

### Tier 3: Asked Regularly (5-15% of interviews)
11. **Container With Most Water** - LeetCode #11
12. **Search in Rotated Sorted Array** - LeetCode #33
13. **Trapping Rain Water** - LeetCode #42
14. **LRU Cache** - LeetCode #146
15. **Longest Increasing Subsequence** - LeetCode #300
16. **Merge Intervals** - LeetCode #56
17. **Number of Islands** - LeetCode #200
18. **Edit Distance** - LeetCode #72
19. **Word Ladder** - LeetCode #127
20. **Minimum Window Substring** - LeetCode #76

---

# APPLE MUST-KNOW PROBLEMS {#apple}

## Top 20 Problems (In Order of Frequency)

### Tier 1: Most Asked (30%+ of interviews)
1. **Reverse Linked List** - LeetCode #206
2. **Binary Tree Level Order Traversal** - LeetCode #102
3. **Validate Binary Search Tree** - LeetCode #98
4. **Two Sum** - LeetCode #1
5. **Best Time to Buy and Sell Stock** - LeetCode #121

### Tier 2: Frequently Asked (15-30% of interviews)
6. **Valid Parentheses** - LeetCode #20
7. **Binary Tree Inorder Traversal** - LeetCode #94
8. **Symmetric Tree** - LeetCode #101
9. **Invert Binary Tree** - LeetCode #226
10. **Maximum Depth of Binary Tree** - LeetCode #104

### Tier 3: Asked Regularly (5-15% of interviews)
11. **Merge Two Sorted Lists** - LeetCode #21
12. **Remove Nth Node From End** - LeetCode #19
13. **Palindrome Linked List** - LeetCode #234
14. **Balanced Binary Tree** - LeetCode #110
15. **Convert Sorted Array to BST** - LeetCode #108
16. **Lowest Common Ancestor** - LeetCode #236
17. **Longest Substring Without Repeating Characters** - LeetCode #3
18. **Container With Most Water** - LeetCode #11
19. **3Sum** - LeetCode #15
20. **House Robber** - LeetCode #198

---

# PATTERN-BASED ORGANIZATION {#patterns}

## Pattern 1: Two Pointers (8 problems)

```python
# When to use: Two arrays/string, or need to find pair/target
# Key: Start from opposite ends, move based on comparison

1. Two Sum
2. 3Sum
3. Container With Most Water
4. Merge Sorted Array
5. Remove Duplicates from Sorted Array
6. Trapping Rain Water
7. Longest Palindromic Substring
8. Merge Two Sorted Lists
```

### Template
```python
def two_pointer_solution(data):
    left, right = 0, len(data) - 1
    
    while left < right:
        # Process current pair
        if condition:
            left += 1
        else:
            right -= 1
    
    return result
```

---

## Pattern 2: Sliding Window (6 problems)

```python
# When to use: Substring/subarray with specific property
# Key: Maintain window of valid elements, expand/contract

1. Longest Substring Without Repeating Characters
2. Minimum Window Substring
3. Longest Substring with K Distinct Characters
4. Sliding Window Maximum
5. Permutation in String
6. Minimum Size Subarray Sum
```

### Template
```python
def sliding_window(s, pattern):
    window = {}
    left = 0
    result = []
    
    for right in range(len(s)):
        # Add right character
        window[s[right]] = window.get(s[right], 0) + 1
        
        # Shrink window from left
        while not is_valid(window):
            del window[s[left]]
            left += 1
        
        result.append(window)
    
    return result
```

---

## Pattern 3: Dynamic Programming (10 problems)

```python
# When to use: Optimization problems with overlapping subproblems
# Key: Break problem into subproblems, use memoization

1. Climbing Stairs
2. House Robber
3. Longest Increasing Subsequence
4. Edit Distance
5. Coin Change
6. Decode Ways
7. Regular Expression Matching
8. Word Break
9. Maximum Path Sum
10. Best Time to Buy and Sell Stock (variants)
```

### Template
```python
def dp_solution(n):
    # Memoization
    memo = {}
    
    def helper(state):
        if state in memo:
            return memo[state]
        
        if base_case:
            return base_value
        
        result = compute_subproblems(state)
        memo[state] = result
        return result
    
    return helper(initial_state)
```

---

## Pattern 4: Tree Traversal (8 problems)

```python
# When to use: Tree/binary tree problems
# Key: DFS (preorder, inorder, postorder) or BFS (level order)

1. Binary Tree Level Order Traversal
2. Binary Tree Inorder Traversal
3. Lowest Common Ancestor
4. Validate Binary Search Tree
5. Maximum Path Sum
6. Balanced Binary Tree
7. Serialize and Deserialize Binary Tree
8. Path Sum
```

### Template - Recursive
```python
def tree_dfs(node):
    if not node:
        return
    
    # Preorder: process node, left, right
    process(node)
    tree_dfs(node.left)
    tree_dfs(node.right)
```

### Template - Iterative (Level Order)
```python
from collections import deque

def tree_bfs(root):
    queue = deque([root])
    result = []
    
    while queue:
        level = []
        for _ in range(len(queue)):
            node = queue.popleft()
            level.append(node.val)
            if node.left:
                queue.append(node.left)
            if node.right:
                queue.append(node.right)
        result.append(level)
    
    return result
```

---

## Pattern 5: Graph (BFS/DFS) (7 problems)

```python
# When to use: Graph traversal, connectivity, shortest path
# Key: Build graph (adjacency list), then DFS/BFS

1. Number of Islands
2. Course Schedule (Topological Sort)
3. Course Schedule II
4. Clone Graph
5. Pacific Atlantic Water Flow
6. Word Ladder
7. Rotting Oranges
```

### Template - DFS
```python
def graph_dfs(graph, start):
    visited = set()
    result = []
    
    def dfs(node):
        if node in visited:
            return
        visited.add(node)
        result.append(node)
        
        for neighbor in graph[node]:
            dfs(neighbor)
    
    dfs(start)
    return result
```

---

## Pattern 6: Hash Map/Set (6 problems)

```python
# When to use: Counting, grouping, quick lookup
# Key: Use hash for O(1) access

1. Two Sum (hash map for complements)
2. Valid Anagram (character counts)
3. Group Anagrams (sorted string as key)
4. Contains Duplicate (quick membership)
5. Intersection of Two Arrays (set operations)
6. Happy Number (cycle detection)
```

### Template
```python
def hash_solution(data):
    count_map = {}
    
    for item in data:
        count_map[item] = count_map.get(item, 0) + 1
    
    # Process map for result
    return process(count_map)
```

---

## Pattern 7: Linked List (5 problems)

```python
# When to use: Linked list manipulation
# Key: Two pointer technique (slow/fast)

1. Reverse Linked List
2. Merge Two Sorted Lists
3. Merge k Sorted Lists
4. Palindrome Linked List
5. Remove Nth Node From End
```

### Template
```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def linked_list_solution(head):
    # Use dummy node
    dummy = ListNode(0)
    dummy.next = head
    
    prev = dummy
    current = head
    
    while current:
        # Process current
        current = current.next
        prev = prev.next
    
    return dummy.next
```

---

## Pattern 8: Backtracking (4 problems)

```python
# When to use: Permutations, combinations, subsets
# Key: Explore all possibilities, backtrack

1. Permutations
2. Combinations
3. Word Break II
4. N-Queens (if asked)
```

### Template
```python
def backtrack_solution(candidates):
    result = []
    
    def backtrack(path, remaining):
        if not remaining:
            result.append(path[:])
            return
        
        for i, item in enumerate(remaining):
            path.append(item)
            backtrack(path, remaining[:i] + remaining[i+1:])
            path.pop()
    
    backtrack([], candidates)
    return result
```

---

# INTERVIEW STRATEGY {#strategy}

## Pre-Interview Preparation (2 weeks minimum)

### Week 1: Master Core Patterns
**Day 1-2:** Two Pointers + Sliding Window
- Two Sum
- Container With Most Water
- Longest Substring Without Repeating Characters
- Minimum Window Substring

**Day 3-4:** Hash Map + Dynamic Programming
- Valid Anagram
- Group Anagrams
- Climbing Stairs
- House Robber

**Day 5-6:** Trees + Graphs
- Binary Tree Level Order Traversal
- Number of Islands
- LRU Cache

**Day 7:** Linked Lists + Backtracking
- Reverse Linked List
- Merge k Sorted Lists
- Permutations

### Week 2: Company-Specific Practice
**Day 1-2:** Your target company's Tier 1 problems
**Day 3-4:** Tier 2 problems
**Day 5-6:** Tier 3 problems + Hard variations
**Day 7:** Full mock interview (2 hours, 3 problems)

---

## During Interview (60-90 minutes for 1-2 problems)

### Timeline
```
0-2 min:   Listen & Clarify
2-5 min:   Discuss Approach (brute force ‚Üí optimal)
5-20 min:  Code Solution
20-25 min: Test with Examples
25-30 min: Optimize & Discuss Tradeoffs
```

### Talking Points
1. **"Let me understand the problem..."**
   - Confirm input/output
   - Clarify constraints
   - Ask about edge cases

2. **"I see a few approaches..."**
   - Brute force: O(n¬≤) or O(2‚Åø)
   - Optimized: O(n log n) or O(n)
   - Discuss tradeoffs

3. **"Let me trace through this example..."**
   - Walk through algorithm
   - Show data structure changes
   - Verify correctness

4. **"The time complexity is O(...) because..."**
   - Explain each part
   - Compare approaches
   - Justify design choices

5. **"I can optimize this by..."**
   - Better algorithm
   - Better data structure
   - Space/time tradeoff

---

## Common Mistakes to Avoid

‚ùå Jumping to code without discussing approach
‚ùå Writing code that doesn't compile
‚ùå Not testing with examples
‚ùå Forgetting edge cases (empty input, single element, duplicates)
‚ùå Not explaining your thinking
‚ùå Overcomplicating solutions
‚ùå Ignoring time/space complexity
‚ùå Not optimizing when asked

---

## Complexity Cheat Sheet

### Time Complexity
| Complexity | Example | Notes |
|-----------|---------|-------|
| O(1) | Array access, hash lookup | Best case |
| O(log n) | Binary search | Divide & conquer |
| O(n) | Linear search, single loop | Common |
| O(n log n) | Merge sort, heapsort | Optimal for sorting |
| O(n¬≤) | Nested loops, bubble sort | Acceptable for arrays |
| O(2‚Åø) | Subsets, backtracking | Exponential |
| O(n!) | Permutations | Rare |

### Space Complexity
| Complexity | Example |
|-----------|---------|
| O(1) | Constant extra space |
| O(log n) | Recursion depth |
| O(n) | Array, hash map, queue |
| O(n¬≤) | 2D array, matrix |

---

## Top 10 Companies' Interview Focus

### Frequency of Problem Types (FAANG Average)
1. **Arrays/Strings:** 30%
2. **Trees/Graphs:** 25%
3. **Linked Lists:** 10%
4. **Hash Maps:** 10%
5. **Dynamic Programming:** 15%
6. **Backtracking:** 5%
7. **Stack/Queue:** 3%
8. **Design/System:** 2%

---

## Success Rate Improvement Timeline

| Week | Status | Success Rate |
|------|--------|--------------|
| Week 1 | Learning | 30-40% |
| Week 2 | Understanding | 50-60% |
| Week 3 | Proficient | 70-80% |
| Week 4 | Expert | 90-95% |

---

## Final Checklist Before Interview

- [ ] **Practice:** 50+ problems from your target company
- [ ] **Understand:** Every solution in depth (not memorized)
- [ ] **Explain:** Can articulate every solution clearly
- [ ] **Optimize:** Know how to improve solutions
- [ ] **Test:** Handle all edge cases
- [ ] **Communicate:** Ask clarifying questions
- [ ] **Mock Interview:** Do 3-5 timed interviews
- [ ] **Confidence:** Believe you can solve anything

---

## If You Get Stuck During Interview

```python
# Say these phrases:
1. "Let me think about this for a moment..."
2. "Can I ask a clarifying question...?"
3. "Let me consider the brute force approach first..."
4. "What if I use a hash map to..."
5. "Let me trace through this with the example..."
6. "Can I optimize this further by..."
```

### Don't Say:
‚ùå "I don't know"
‚ùå "I've never seen this problem"
‚ùå "Can you give me a hint?"
‚ùå "Is this correct?" (on every line)

---

## After Getting Rejected

### Analyze Failed Interview:
1. Which pattern was it?
2. Did I understand the problem?
3. Where did I get stuck?
4. How would I solve it now?
5. Which similar problems can help?

### Action Items:
- Solve 5-10 similar problems
- Master the pattern completely
- Do more mock interviews
- Apply again in 2-3 weeks

---

## Your Path to FAANG

```
Week 1: Learn (8 patterns + fundamentals)
  ‚Üì
Week 2: Practice (50+ problems)
  ‚Üì
Week 3: Specialize (company-specific, tier 1-2)
  ‚Üì
Week 4: Master (tier 3 + hard problems)
  ‚Üì
Interview ‚Üí Success! üéâ
```

---

## Resources (Free/Paid)

### Free
- LeetCode (Free tier has most problems)
- GeeksforGeeks (Detailed explanations)
- YouTube: NeetCode, Abdul Bari, Striver

### Paid (Worth it)
- LeetCode Premium (Company-specific filters)
- AlgoExpert (Excellent video explanations)
- InterviewBit (Curated path)

---

## Success Stories

**Average Timeline to FAANG Offer:**
- **Beginner (0 experience):** 12-16 weeks of consistent practice
- **Intermediate (some experience):** 6-10 weeks
- **Advanced (coding background):** 3-4 weeks

**Key Success Factor:** Consistency beats intensity. 1 hour daily > 10 hours once a week.

---

**YOU'VE GOT THIS! üöÄ**

Master these 50 problems, understand the 8 patterns, and you're ready for any FAANG interview!

Start with the most frequent problems for your target company, then move to Tier 2 and 3. Focus on understanding patterns, not memorizing solutions.

**4 weeks of consistent practice = FAANG interview-ready!**

