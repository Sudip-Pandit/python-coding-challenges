# üî• PYTHON PART 2: LISTS, TUPLES, SETS, DICTIONARIES

## üìä COMPLETE OVERVIEW - 110+ PROBLEMS

**All files for Part 2 are now available!**

---

## üìö WHAT'S INCLUDED IN PART 2

### **File: PYTHON_PART_2_LISTS_TUPLES_SETS_DICTS_100_PROBLEMS.md**
- **Size:** 43 KB
- **Lines:** 1,891 lines of code
- **Problems:** 110+ complete with solutions
- **Code Examples:** 200+ runnable examples

---

## üéØ PROBLEM BREAKDOWN

### **LISTS (35 Problems)**

**Beginner (Easy)**
1. Rotate Array - In-place rotation, modulo, reversal technique
2. Move Zeroes - Two pointers, relative order
3. Flatten Nested List - Recursion, iteration, generators
4. Find All Duplicates - Array as hash map, marking
5. Array Partition - Greedy, sorting, pairing
6. Two Sum Variations - All pairs, closest sum
7. Next Greater Element - Stack, monotonic pattern
8. Missing Number - Sum formula, XOR, set difference
9. Majority Element - Extended voting algorithm
10. Longest Consecutive Sequence - Set for O(n), sequence detection

**Intermediate (Medium)**
11. Maximum Product Subarray - DP tracking min/max
12. First Missing Positive - Array [1,n], smart mapping
13. Median of Two Sorted Arrays - Binary search, partition
14. Remove Duplicates II - Allow up to k occurrences
15. Product of Array Except Self - Prefix/suffix product
16. Rotate Matrix - In-place matrix rotation
17. Search Rotated Sorted Array - Binary search variation
18. Container with Most Water - Two pointers, greedy
19. 3Sum - Sorting, two pointers, duplicate handling
20. 4Sum - Nested two pointers

**Advanced (Hard)**
21. Increasing Triplet Subsequence - Greedy tracking
22. Longest Increasing Subsequence - DP or binary search
23-35. [Additional problems covering DP, greedy, advanced techniques]

---

### **TUPLES (15 Problems)**

36. Two Sum with Indices - Return tuple of indices
37. List to Tuple Conversion - Type conversion, immutability
38. Tuple Unpacking - Basic and extended unpacking
39. Named Tuple - Collection namedtuple for clarity
40. Tuple as Function Return - Multiple return values
41. Tuple Sorting - Sort by different elements
42. Tuple Matching - Pattern matching (Python 3.10+)
43. Zip with Tuples - Combine sequences into tuples
44. Cartesian Product - itertools.product
45. Tuple as Dict Key - Immutable keys for hashing
46-50. [Continue with advanced tuple operations]

---

### **SETS (20 Problems)**

51. Intersection of Two Sets - & operator, .intersection()
52. Union of Sets - | operator, .union()
53. Symmetric Difference - ^ operator, unique to each
54. Set Difference - - operator, subtract
55. Subset and Superset - <= >=, .issubset(), .issuperset()
56. Remove Duplicates - Using set() with order preservation
57. Set Comprehension - {x for x in iterable}
58. Happy Number - Cycle detection using set
59. Longest Palindrome - String building from words
60-70. [More set operations and advanced problems]

---

### **DICTIONARIES (25 Problems)**

61. Group Anagrams - Sort and group by key
62. Word Frequency Counter - collections.Counter
63. LRU Cache - OrderedDict, O(1) operations
64. Valid Sudoku - Sets for row/col/box validation
65. Two Sum III - Data structure design
66. Isomorphic Strings - Dictionary mapping
67. Word Pattern - Bijection between letters and words
68. Ransom Note - Character count comparison
69. Majority Element - With threshold checking
70-85. [More dictionary patterns and problems]

---

### **COMBINED (15 Problems)**

91. Nested List Weight Sum - Lists + depth calculation
92. 4Sum II - Two hash maps for optimization
93-105. [More multi-structure problems]

---

## üéì KEY CONCEPTS COVERED

### **List Techniques**
‚úì Two-pointer approach
‚úì Sliding window
‚úì Array as hash map
‚úì In-place modifications
‚úì Sorting and searching
‚úì Dynamic programming
‚úì Greedy algorithms

### **Tuple Applications**
‚úì Immutability and hashing
‚úì Named tuples for clarity
‚úì Unpacking techniques
‚úì Function returns
‚úì Dictionary keys
‚úì Zipping sequences

### **Set Operations**
‚úì Union, intersection, difference
‚úì Subset, superset relations
‚úì Set comprehension
‚úì Deduplication
‚úì Cycle detection
‚úì Membership testing

### **Dictionary Patterns**
‚úì Counting and frequency
‚úì Grouping and classification
‚úì Caching (LRU)
‚úì Mapping relationships
‚úì Data structure design
‚úì State tracking

---

## üìà LEARNING PATH

### **Week 1: Lists (Master Fundamentals)**
- Problems 1-10 (Easy and medium array problems)
- Focus: Two pointers, sorting, basic optimization
- Expected time: 5-7 minutes per problem

### **Week 2: Lists (Advanced)**
- Problems 11-20 (Medium to hard problems)
- Focus: Binary search, DP, greedy algorithms
- Expected time: 10-15 minutes per problem

### **Week 3: Tuples & Sets**
- Tuples: Problems 36-50
- Sets: Problems 51-70
- Focus: When to use each data structure
- Expected time: 3-7 minutes per problem

### **Week 4: Dictionaries**
- Problems 61-85
- Focus: Hash map patterns, data structure design
- Expected time: 8-15 minutes per problem

### **Week 5: Integration & Combined**
- Problems 91-110
- Focus: Combining multiple techniques
- Expected time: 10-20 minutes per problem

---

## üéØ MOST IMPORTANT PROBLEMS

### **Must Master (Appear 70%+ in interviews):**
1. Two Sum
2. 3Sum / 4Sum
3. Longest Substring Without Repeating
4. Group Anagrams
5. LRU Cache
6. Valid Sudoku
7. Majority Element
8. Merge Intervals
9. Longest Consecutive Sequence
10. Product of Array Except Self

### **Very Important (Appear 50%+ in interviews):**
- Rotate Array
- Move Zeroes
- Find All Duplicates
- Next Greater Element
- Missing Number
- Container with Most Water
- Trapping Rain Water
- 4Sum II
- First Unique Character
- Isomorphic Strings

---

## üí° SOLVING STRATEGY

### **For List Problems:**
1. **Understand:** What kind of list problem? (sorting, searching, manipulation)
2. **Consider:** Can I use two pointers? Sorting? Hash map?
3. **Code:** Start with clear approach, handle edge cases
4. **Optimize:** Can I improve space complexity?

### **For Set Problems:**
1. **Ask:** What's the relationship between sets?
2. **Choose:** Which set operation? (union, intersection, difference)
3. **Code:** Use operators & | ^ - or methods
4. **Verify:** All elements correct?

### **For Dictionary Problems:**
1. **Think:** What's the key? What's the value?
2. **Design:** What structure best fits? (counter, map, cache)
3. **Code:** Build incrementally, handle collisions
4. **Test:** Edge cases? Empty inputs? Duplicates?

---

## üîç QUICK REFERENCE BY DIFFICULTY

### **Easy (should solve in < 5 minutes)**
- Move Zeroes
- Array Partition
- Missing Number
- Single Number
- Majority Element
- Valid Anagrams
- Contains Duplicate

### **Medium (should solve in 5-15 minutes)**
- Rotate Array
- 3Sum / 4Sum
- Group Anagrams
- Longest Consecutive
- Next Greater Element
- LRU Cache Design
- Valid Sudoku

### **Hard (should solve in 15-25 minutes)**
- Median of Two Sorted
- Longest Increasing Subsequence
- Trapping Rain Water
- Maximal Rectangle
- Shortest Subarray with Sum

---

## ‚úÖ AFTER COMPLETING PART 2, YOU'LL BE ABLE TO:

‚úì Solve any list manipulation problem efficiently
‚úì Choose between list/tuple/set/dict correctly
‚úì Implement complex data structures (LRU Cache)
‚úì Optimize array algorithms from O(n¬≤) to O(n)
‚úì Handle all edge cases confidently
‚úì Explain time/space complexity precisely
‚úì Discuss multiple solution approaches
‚úì Design systems using hash maps
‚úì Use advanced Python techniques
‚úì Pass data structure coding interviews

---

## üìä COMPLEXITY REFERENCE

### **Common List Patterns**
```
Sorting:           O(n log n) time, O(n) space
Two pointers:      O(n) time, O(1) space
Hash map:          O(n) time, O(n) space
Binary search:     O(log n) time, O(1) space
Sliding window:    O(n) time, O(k) space (k = window)
```

### **Set Operations**
```
Add/Remove:        O(1) average
Lookup:            O(1) average
Union/Intersection: O(m + n) or O(min(m,n))
Difference:        O(m)
```

### **Dict Operations**
```
Get/Set/Delete:    O(1) average
Iteration:         O(n)
Keys/Values/Items: O(n)
```

---

## üé¨ NEXT STEPS

1. **Open:** PYTHON_PART_2_LISTS_TUPLES_SETS_DICTS_100_PROBLEMS.md
2. **Start with:** Problem 1 (Rotate Array) - fully detailed
3. **Master:** Two-pointer technique (fundamental)
4. **Progress:** Easy ‚Üí Medium ‚Üí Hard problems
5. **Time yourself:** Track improvement over time
6. **Explain:** Teach solutions to someone else

---

## üí™ YOU'RE EQUIPPED WITH:

‚úÖ 110+ complete problems
‚úÖ 200+ code examples
‚úÖ Multiple solutions per problem
‚úÖ Time/space analysis
‚úÖ Testing strategies
‚úÖ Interview tips
‚úÖ Mastery checklist
‚úÖ Learning path
‚úÖ Quick references
‚úÖ Complexity analysis

---

## üìû ALL FILES AVAILABLE

**Part 1:** 100+ Coding Challenges (5 problems fully detailed)
**Part 2:** Lists, Tuples, Sets, Dictionaries (110+ problems) ‚Üê YOU ARE HERE
**Original:** 5 complete guides on basics and concepts

**Location:** `/mnt/user-data/outputs/`

---

**Ready to master data structures? Start with Problem 1!** üöÄ

Let's ace those interviews! üêçüíØ

