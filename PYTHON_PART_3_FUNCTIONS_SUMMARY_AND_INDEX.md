# üî• PYTHON PART 3: FUNCTIONS - 100+ CHALLENGES

**Complete Guide to Python Functions: From Basics to Advanced**

---

## üìä COMPLETE OVERVIEW

**File:** PYTHON_PART_3_FUNCTIONS_100_PROBLEMS.md
- **Size:** 42 KB
- **Lines:** 1,982
- **Problems:** 100+ complete with solutions
- **Code Examples:** 150+ runnable examples

---

## üéØ PROBLEM BREAKDOWN

### **BASIC FUNCTIONS (20 Problems)**

**1. Function Definition & Calling**
- Basic function structure
- Return statements
- Multiple returns
- Return tuples/dicts
- Function naming conventions
- Docstrings

**2. Scope & Namespace**
- Local scope
- Global scope
- Enclosing scope
- LEGB rule
- Global keyword
- Nonlocal keyword

**3. Default Arguments**
- Basic defaults
- Multiple defaults
- Mutable default pitfall
- Correct default patterns
- Default evaluation timing

**4. Type Hints**
- Basic type hints
- Complex type hints
- Typing module
- List, Dict, Tuple hints
- Optional and Union
- Variable annotations

**5. Documentation**
- Google style docstrings
- NumPy style docstrings
- One-liner docstrings
- Comprehensive docstrings
- Examples in docstrings

**6-20. [Additional basics...]**
- Function composition
- Lambda basics
- Built-in functions
- Error handling in functions

---

### **PARAMETERS & ARGUMENTS (20 Problems)**

**6. *args (Variable Positional Arguments)**
- Basic *args usage
- *args with regular parameters
- Multiple parameters with *args
- Unpacking with *args
- *args as list/tuple

**7. **kwargs (Variable Keyword Arguments)**
- Basic **kwargs usage
- **kwargs with regular parameters
- Combining *args and **kwargs
- Unpacking with **kwargs
- Safe **kwargs access

**8. Keyword-Only Arguments**
- Force keyword arguments with *
- Multiple keyword-only args
- Mix positional and keyword-only
- Improve code clarity

**9. Positional-Only Arguments**
- Force positional arguments with /
- Mix positional-only with others
- Backward compatibility

**10-20. [Parameter combinations...]**
- All parameter types together
- Parameter order rules
- Function signature patterns
- Real-world parameter examples

---

### **RETURN VALUES & RECURSION (20 Problems)**

**10. Return Multiple Values**
- Return tuples
- Return dictionaries
- Return named tuples
- Return lists
- Tuple unpacking

**11. Recursion - Factorial**
- Simple recursion
- Base and recursive cases
- Memoization
- Iterative alternative
- Complexity analysis

**12. Recursion - Fibonacci**
- Naive recursion (slow)
- Memoization (optimized)
- Iterative approach (best)
- Performance comparison

**13. Recursion - Sum List**
- Sum elements recursively
- Accumulator pattern
- Iterative version
- List traversal

**14. Recursion - Binary Search**
- Recursive binary search
- Iterative binary search
- Time complexity O(log n)
- Space complexity

**15-20. [More recursion patterns...]**
- Merge sort
- Quick sort
- Tree traversal
- Backtracking problems

---

### **DECORATORS (15 Problems)**

**15. Basic Decorator**
- Simple decorator structure
- Decorator with arguments
- Timing decorator
- Logging decorator
- Using functools.wraps

**16. Decorator with Arguments**
- Decorator factory pattern
- Retry decorator
- Parametrized behavior

**17. Stacking Decorators**
- Multiple decorators
- Decorator order
- Combining behaviors
- Validation decorators

**18-25. [Advanced decorators...]**
- Class decorators
- Property decorators
- Static/class method decorators
- Custom decorators for caching

---

### **CLOSURES & HIGHER ORDER (15 Problems)**

**18. Closures**
- Closure concept
- Accessing outer scope
- Nonlocal variables
- Factory functions

**19. Map Function**
- Basic map usage
- Map with multiple iterables
- Map vs list comprehension
- Transforming data

**20. Filter Function**
- Basic filter usage
- Filter with predicates
- Filter vs list comprehension
- Selecting elements

**21-30. [More higher-order functions...]**
- Reduce function
- Sorted with key
- Any/all functions
- Function composition

---

### **GENERATORS & ITERATORS (10 Problems)**

**21. Generator Functions with yield**
- yield keyword
- Lazy evaluation
- Memory efficiency
- Generator iteration

**22-30. [More generators...]**
- Generator expressions
- Generator methods (send, throw)
- Context managers
- Iterator protocol

---

## üéì KEY CONCEPTS COVERED

### **Fundamental Concepts**
‚úì Function definition and calling
‚úì Scope and namespace (LEGB)
‚úì Return values and returns
‚úì Parameters vs arguments

### **Parameter Handling**
‚úì Positional arguments
‚úì Keyword arguments
‚úì Default values
‚úì *args (variable positional)
‚úì **kwargs (variable keyword)
‚úì Positional-only (/)
‚úì Keyword-only (*)
‚úì Argument unpacking

### **Advanced Features**
‚úì Type hints and annotations
‚úì Docstrings and documentation
‚úì Decorators
‚úì Closures
‚úì Higher-order functions
‚úì Generators and yield
‚úì Lambda functions
‚úì Recursion

### **Best Practices**
‚úì Function naming conventions
‚úì Proper documentation
‚úì Type hints for clarity
‚úì Error handling
‚úì Code organization
‚úì Performance optimization
‚úì Memory efficiency

---

## üìà LEARNING PATH

### **Week 1: Function Fundamentals**
- Problems 1-5 (Basics, scope, defaults, hints, docs)
- Master: How functions work
- Time per problem: 5-10 minutes

### **Week 2: Parameters & Arguments**
- Problems 6-10 (*args, **kwargs, keyword-only)
- Master: Flexible function signatures
- Time per problem: 7-12 minutes

### **Week 3: Recursion**
- Problems 11-14 (Recursion patterns)
- Master: Recursive thinking
- Time per problem: 10-15 minutes

### **Week 4: Decorators**
- Problems 15-17 (Decorators and stacking)
- Master: Function modification
- Time per problem: 10-15 minutes

### **Week 5: Advanced Topics**
- Problems 18-21 (Closures, higher-order, generators)
- Master: Advanced Python patterns
- Time per problem: 10-20 minutes

---

## üåü MOST IMPORTANT PROBLEMS

### **Must Master (appear 80%+ in interviews):**
1. Function definition and calling
2. Default arguments
3. *args and **kwargs
4. Return multiple values
5. Recursion (factorial, fibonacci)
6. Basic decorators
7. Closures
8. Lambda functions
9. Map and filter
10. Generators with yield

### **Very Important (appear 60%+ in interviews):**
- Type hints
- Docstrings
- Keyword-only arguments
- Memoization
- Decorator with arguments
- Higher-order functions
- Generator expressions
- Context managers

---

## üí° SOLVING STRATEGIES

### **For Basic Functions:**
1. Understand: What should function do?
2. Define: Input parameters, output
3. Implement: Step by step
4. Test: With various inputs
5. Document: Clear docstring

### **For Parameter Problems:**
1. Ask: What parameters needed?
2. Choose: Regular, *args, **kwargs?
3. Order: positional, *, keyword-only
4. Default: Safe defaults?
5. Unpack: How to pass?

### **For Recursion:**
1. Base case: When to stop?
2. Recursive case: How to reduce?
3. Structure: Return statement?
4. Test: Small inputs first
5. Optimize: Memoization needed?

### **For Decorators:**
1. Understand: What to modify?
2. Wrapper: How to wrap?
3. Args/Kwargs: Handle properly?
4. Return: Preserve metadata
5. Order: Multiple decorators?

---

## üìä COMPLEXITY REFERENCE

```
Function Call:         O(1) per call
Recursion Depth:       O(n) space for call stack
Generator Creation:    O(1) - lazy evaluation
Decorator Wrapping:    O(1) per call
Closure Creation:      O(1)
Map/Filter:            O(n) time per element
```

---

## ‚úÖ AFTER COMPLETING PART 3

You will be able to:
‚úì Define functions for any problem
‚úì Handle flexible parameters
‚úì Implement recursive solutions
‚úì Create and apply decorators
‚úì Understand closures
‚úì Use higher-order functions
‚úì Create generators efficiently
‚úì Write clean function signatures
‚úì Document code properly
‚úì Optimize performance
‚úì Pass function-focused interviews

---

## üîç QUICK REFERENCE

### **Function Definition**
```python
def function_name(pos_only, /, regular, *args, kw_only, **kwargs):
    """Docstring."""
    return result
```

### **Common Patterns**

**Multiple Returns:**
```python
return value1, value2  # tuple
return {"key": value}  # dictionary
```

**Recursion Template:**
```python
def recursive_func(n):
    if base_condition:
        return base_case
    return recursive_case(n-1)
```

**Decorator Template:**
```python
@decorator
def function():
    pass
```

**Generator Template:**
```python
def generator():
    for item in iterable:
        yield item
```

---

## üìû ALL PYTHON INTERVIEW PARTS

**Part 1:** 100+ General Coding Challenges
- Easy, Medium, Hard problems
- All major algorithms
- Multiple solutions

**Part 2:** 110+ Lists, Tuples, Sets, Dicts
- Data structure mastery
- Collections operations
- Real-world patterns

**Part 3:** 100+ Functions ‚Üê YOU ARE HERE
- Function fundamentals
- Advanced techniques
- Design patterns

**Total:** 310+ Problems | 1000+ Solutions | 1000+ Code Examples

---

## üé¨ NEXT STEPS

1. **Open:** PYTHON_PART_3_FUNCTIONS_100_PROBLEMS.md
2. **Start:** Problem 1 (Function Basics)
3. **Master:** One concept per session
4. **Progress:** Easy ‚Üí Medium ‚Üí Hard
5. **Practice:** Implement everything locally

---

## üí™ YOU'RE EQUIPPED WITH:

‚úÖ 100+ function problems
‚úÖ 150+ code examples
‚úÖ Multiple solutions per problem
‚úÖ Best practices
‚úÖ Common pitfalls to avoid
‚úÖ Performance tips
‚úÖ Interview strategies
‚úÖ Complexity analysis
‚úÖ Complete documentation
‚úÖ Learning path

---

**Ready to master Python functions? Start now!** üöÄ

Time to ace those interviews! üêçüíØ

